"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _coding = _interopRequireDefault(require("../coding"));
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var _typeof = function(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
};
var DcUtilitaire = /**
 * MiraJS utils
 * All useful javascript functions
 * @copyright DcCorp.
 * @author Daniel SAKOU
 * 15/07/2020
 */ /*#__PURE__*/ function() {
    "use strict";
    function DcUtilitaire() {
        _classCallCheck(this, DcUtilitaire);
        _defineProperty(this, "__CHAR_WIDTH", 7);
        _defineProperty(this, /**
     * @type {{create: Function, read: Function}}
     */ "cookie", {
            /**
         * @param _name {String}
         * @param _value {string}
         * @param _days {Number}
         * Create an cookie
         */ create: function create(_name, _value, _days) {
                var expires;
                if (_days) {
                    var date = new Date();
                    date.setTime(date.getTime() + _days * 24 * 60 * 60 * 1000);
                    expires = "; expires=" + date.toGMTString();
                } else expires = "";
                document.cookie = _name + "=" + _value + expires + "; path=/";
            },
            /**
         * @param _name {String}
         * Read an cookie
         * @return {string|null}
         */ read: function read(_name) {
                var nameEQ = _name + "=";
                var ca = document.cookie.split(';');
                for(var i = 0; i < ca.length; i++){
                    var c = ca[i];
                    while(c.charAt(0) === ' ')c = c.substring(1, c.length);
                    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                }
                return null;
            }
        });
        _defineProperty(this, /**
     * @type {{search: {string: (function(*=, *): Array)}}}
     */ "algo", {
            search: {
                /**
             * @param _val {String}
             * @param _tab {Array}
             * @param _casse {Boolean}
             * Search _tab for item matching with _val
             * @return {Array}
             */ string: function(_val, _tab, _casse) {
                    var ret = [];
                    try {
                        if (_tab != null && _tab.length !== undefined && typeof _val === "string") {
                            for(var i = 0; i < _tab.length; i++){
                                if (_casse === undefined) {
                                    if (_tab[i].toLowerCase().indexOf(_val.toLowerCase()) !== -1) ret.push(i);
                                } else {
                                    if (_casse) {
                                        if (_tab[i].indexOf(_val) !== -1) ret.push(i);
                                    } else {
                                        if (_tab[i].toLowerCase().indexOf(_val.toLowerCase()) !== -1) ret.push(i);
                                    }
                                }
                            }
                        } else console.log("dc-algo-search-string: Wrong description types");
                    } catch (e) {
                        console.log(e);
                    }
                    return ret;
                }
            }
        });
        _defineProperty(this, /**
     * @type {{check: {password: (function(*): (boolean|string[]|void|RegExpMatchArray|Promise<Response | undefined>)), telephone: (function(*): boolean), email: (function(*): boolean), username: (function(*): (string[] | boolean | void | RegExpMatchArray | Promise<Response | undefined>))}}}
     */ "form", {
            check: {
                /**
             * @param _password {String}
             * @return {boolean|string[]|void|RegExpMatchArray|Promise<Response | undefined>}
             */ password: function password(_password) {
                    return _password.length >= 6 && _password.match(/[a-zA-Z0-9]+/);
                },
                /**
             * @param _username {string}
             * @return {string[] | boolean | void | RegExpMatchArray | Promise<Response | undefined>}
             */ username: function username(_username) {
                    return _username.match(/[a-zA-Z0-9\s_\-@]{1,30}/) && _username.length <= 30 && _username.length >= 3;
                },
                /**
             * @param _telephone {string}
             * @return {boolean}
             */ telephone: function telephone(_telephone) {
                    return !!_telephone.match(/^[+]?[0-9]{2,3}[-. \s0-9]{0,2}([-. \s]?[0-9]{2}){4}$/);
                },
                /**
             * @param _email {string}
             * @return {boolean}
             */ email: function email(_email) {
                    return !!_email.match(/^[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]{2,}\.[a-z]{2,4}$/);
                }
            }
        });
        _defineProperty(this, /**
     * Captitalizes string
     * @param _val {string}
     */ "toCapitalize", function(_val) {
            var ret = _val;
            try {
                if (typeof _val === "string") {
                    ret = _val.toLowerCase();
                    ret = _val.substr(0, 1).toUpperCase() + _val.substr(1, _val.length);
                }
                console.log("To capitalize fires only on string ");
            } catch (e) {
                console.log("To capitalize : ", e);
            }
            return ret;
        });
        _defineProperty(this, /**
     *
     * @param _value {*}
     * @param _default {*}
     * @return {*}
     */ "isDefined", function(_value, _default1) {
            return _value !== undefined && (typeof _value === "undefined" ? "undefined" : _typeof(_value)) === (typeof _default1 === "undefined" ? "undefined" : _typeof(_default1)) ? _value : _default1;
        });
        _defineProperty(this, /**
     * Energizes css components.
     */ "setWrapped", function() {
            console.log("Wrapping has been desactivated for performance...");
        // set wrapped class to btn
        /*let dc_btn_pop = DcCoding.get('.footer-popup .dc-btn');
        if(typeof dc_btn_pop != "undefined") {
            if (typeof dc_btn_pop.length === "undefined")
                DcCoding.addClass(dc_btn_pop, 'dc-item-wrapp span-blue');
            else {
                for (let i = 0; i < dc_btn_pop.length; i++) {
                    DcCoding.addClass(dc_btn_pop[i], 'dc-item-wrapp span-blue');
                }
            }
        }
        dc_btn_pop = DcCoding.get('.footer-popup .btn');
        if(typeof dc_btn_pop != "undefined") {
            if (typeof dc_btn_pop.length === "undefined")
                DcCoding.addClass(dc_btn_pop, 'dc-item-wrapp span-blue');
            else {
                for (let i = 0; i < dc_btn_pop.length; i++) {
                    DcCoding.addClass(dc_btn_pop[i], 'dc-item-wrapp span-blue');
                }
            }
        }
        dc_btn_pop = DcCoding.get('.btn-icon');
        if(typeof dc_btn_pop != "undefined") {
            if (typeof dc_btn_pop.length === "undefined")
                DcCoding.addClass(dc_btn_pop, 'dc-wrapp');
            else {
                for (let i = 0; i < dc_btn_pop.length; i++) {
                    DcCoding.addClass(dc_btn_pop[i], 'dc-wrapp');
                }
            }
        }


        DcCoding.event({
            name: "click",
            object: ".dc-wrapp",
            callback: function(evt) {
                let btn = evt.currentTarget;
                let tbtn = btn,
                    spans = tbtn.querySelectorAll('span.span-wrapp');
                if (spans != null && typeof spans.length !== "undefined") {
                    for (let i = 0; i < spans.length; i++)
                        spans[i].parentNode.removeChild(spans[i]);
                }

                let x = evt.pageX - DcCoding.getCoords(btn).x,
                    y = evt.pageY - DcCoding.getCoords(btn).y;

                let spanElem = DcCoding.new("span");
                DcCoding.css(spanElem, {
                    width: btn.offsetWidth / 2 + "px",
                    height: btn.offsetHeight / 2 + "px",
                    left: btn.offsetWidth / 4 + "px",
                    top: btn.offsetHeight / 4 + "px"
                });
                DcCoding.setClass(spanElem, 'span-wrapp');
                btn.appendChild(spanElem);
                setTimeout(function () {
                    let span = tbtn.querySelector('span.span-wrapp');
                    if (span != null && typeof span.parentNode !== "undefined")
                        span.parentNode.removeChild(span);
                }, 1100);
            }
        });
        DcCoding.event({
            name: "click",
            object: ".dc-item-wrapp",
            callback: function(evt) {
                let btn = evt.currentTarget;
                let tbtn = btn,
                    spans = tbtn.querySelectorAll('span.span-wrapp');
                if (spans != null && typeof spans.length !== "undefined") {
                    for (let i = 0; i < spans.length; i++)
                        spans[i].parentNode.removeChild(spans[i]);
                }

                let x = evt.pageX - DcCoding.getCoords(btn).x,
                    y = evt.pageY - DcCoding.getCoords(btn).y,
                    obj_x = DcCoding.getCoords(btn).x === 0?(x - DcCoding.getCoords(btn).x):x;

                let spanElem = DcCoding.new("span");
                DcCoding.css(spanElem, {
                    width: btn.offsetHeight + "px",
                    height: btn.offsetHeight + "px",
                    left: obj_x + "px",
                    top: "0"
                });
                DcCoding.setClass(spanElem, 'span-wrapp');
                btn.appendChild(spanElem);
                setTimeout(function () {
                    let span = tbtn.querySelector('span.span-wrapp');
                    if (span != null && typeof span.parentNode !== "undefined")
                        span.parentNode.removeChild(span);
                }, 1100);
            }
        });
        DcCoding.event({
            name: "mousedown",
            object: ".dcx-ripple",
            callback: e=>{
                const span_class = "span.dcx-ripple__effect";
                let obj = e.currentTarget, spans = obj.querySelectorAll(span_class);
                if(spans !== undefined && spans.length > 0)
                    spans.forEach(item=>{
                        DcCoding.remove(item);
                    });
                let { offsetWidth, offsetHeight, offsetLeft } = obj, {x,y} = DcCoding.getCoords(obj);
                let spanW =  offsetWidth / 2,
                    obj_x = e.pageX - DcCoding.getCoords(obj).x,
                    obj_y = e.pageY - DcCoding.getCoords(obj).y;
                if(spanW < 50) {
                    obj_x = spanW / 2;
                    obj_y = offsetHeight / 4;
                }
                if(obj.className.indexOf('long-prog') !== -1)
                    obj_y = 0;
                if(obj_x < 0)
                    obj_x = 0;
                if(obj_x > offsetWidth)
                    obj_x = offsetWidth;
                let spanElem = DcCoding.new("span");
                DcCoding.css(spanElem, {
                    width: spanW + "px",
                    height: spanW + "px",
                    left: obj_x + "px",
                    top: obj_y + "px"
                });
                DcCoding.setClass(spanElem, 'dcx-ripple__effect');
                obj.appendChild(spanElem);

                let time = new Date().getTime();

                obj.addEventListener('mouseup', _e=>{
                    let ntime = new Date().getTime(), diff = ntime - time,
                        duree = diff < 1000 ? 1000 - diff : 100;
                    let done = ()=>{
                        DcCoding.remove(_e.target.querySelector(span_class));
                    };
                    if(diff >= 1000) done();
                    else setTimeout(done, duree);
                });

            }
        });*/ });
        _defineProperty(this, "formatNumber", function(_number, _lang, _currency) {
            var locale = _lang !== undefined ? _lang + '-' + _lang.toUpperCase() : 'en-US', currency = _currency !== undefined ? _currency : "XAF";
            var test = new Intl.NumberFormat(locale, {
                style: 'currency',
                currency: currency
            }).format(_number);
            console.log(test);
            test = test.replace(/([a-zA-Z$￥€]+)/, 't;$1t;');
            var tab = test.split("t;");
            if (tab[0].length > 0) return(/*#__PURE__*/ React.createElement("span", {
                className: "__amount"
            }, tab[0], /*#__PURE__*/ React.createElement("span", {
                className: "__currency"
            }, tab[1])));
            else return(/*#__PURE__*/ React.createElement("span", {
                className: "__amount"
            }, /*#__PURE__*/ React.createElement("span", {
                className: "__currency"
            }, tab[1]), tab[2]));
        });
        _defineProperty(this, "formatNumberStr", function(_number, _lang, _currency) {
            var locale = _lang !== undefined ? _lang + '-' + _lang.toUpperCase() : 'en-US', currency = _currency !== undefined ? _currency : "XAF";
            var test = new Intl.NumberFormat(locale, {
                style: 'currency',
                currency: currency
            }).format(_number);
            console.log(test);
            test = test.replace(/([a-zA-Z$￥€]+)/, 't;$1t;');
            var tab = test.split("t;"), str = "";
            if (tab[0].length > 0) str = tab[0] + " " + tab[1];
            else str = tab[1] + " " + tab[2];
            return str;
        });
        _defineProperty(this, "httpClient", {
            post: function post(_url, _data, _method, _contentType, _header) {
                var headers = {
                    Accept: "application/json",
                    "Content-Type": "application/json"
                };
                if (_contentType === null) headers = {
                    Accept: "application/json"
                };
                if (_header !== undefined) headers = _header;
                return new Promise(function(resolve, reject) {
                    console.log("Fetching url: ", _url);
                    fetch(_url, {
                        body: _contentType === null ? _data : JSON.stringify(_data),
                        method: DCutilities.isDefined(_method, "POST"),
                        headers: headers
                    }).then(function(response) {
                        console.log(_url, " Response ", response);
                        response.json().then(function(jsonResponse) {
                            console.log(_url, " Json Response ", jsonResponse);
                            resolve(jsonResponse);
                        }).catch(function(error) {
                            console.log(_url, " error while parsing json ", error);
                            reject(error);
                        });
                    }).catch(function(error) {
                        console.log(_url, " error while getting response ", error);
                        reject(error);
                    });
                });
            },
            get: function get(_url, _method, _header) {
                var headers = {
                    Accept: "application/json"
                };
                if (_header !== undefined) headers = _header;
                return new Promise(function(resolve, reject) {
                    console.log("Fetching url: ", _url);
                    fetch(_url, {
                        method: DCutilities.isDefined(_method, "GET"),
                        headers: headers
                    }).then(function(response) {
                        console.log(_url, " Response ", response);
                        response.json().then(function(jsonResponse) {
                            console.log(_url, " Json Response ", jsonResponse);
                            resolve(jsonResponse);
                        }).catch(function(error) {
                            console.log(_url, " error while parsing json ", error);
                            reject(error);
                        });
                    }).catch(function(error) {
                        console.log(_url, " error while getting response ", error);
                        reject(error);
                    });
                });
            }
        });
    }
    _createClass(DcUtilitaire, [
        {
            /**
     * @method setRequet
     * @returns {XMLHttpRequest|ActiveXObject}
     */ key: "setRequet",
            value: function setRequet() {
                var result = null;
                if (window.XMLHttpRequest) {
                    result = new window.XMLHttpRequest();
                } else if (window.ActiveXObject) {
                    result = new window.ActiveXObject("Microsoft.XMLHTTP");
                }
                return result;
            }
        },
        {
            /**
     * @method getUrlParam
     * get params contained in url
     * @returns {string}
     */ key: "getUrlParam",
            value: function getUrlParam(_nbParam) {
                var url = window.location.href, tab = url.split("/"), refIndex = tab.length - 1, params = [];
                for(var i = refIndex - _nbParam + 1; i <= refIndex; i++)params.push(tab[i]);
                return params;
            }
        },
        {
            /**
     * @method getUrlParam
     * get params contained in url
     * @returns {{label: string, value: string}[]}
     */ key: "getUrlParams",
            value: function getUrlParams() {
                var url = window.location.href, tab = url.split("?"), params = tab.length > 1 ? tab[tab.length - 1].split("&") : [], ret = [];
                for(var i = 0; i < params.length; i++){
                    var temp = params[i].split("=");
                    ret.push({
                        label: temp[0],
                        value: temp[1]
                    });
                }
                return ret;
            }
        },
        {
            /**
     * @param {Number} _nbr
     * Check if param is numeric
     * @returns {Boolean}
     */ key: "isNumeric",
            value: function isNumeric(_nbr) {
                var temp = parseFloat(_nbr);
                return temp != null && temp >= 0;
            }
        },
        {
            /**
     * @param {Number} _nbr
     * Calculates the ordinate corresponding to an element having param for height so that it is centered on the screen.
     * @returns {Number}
     */ key: "centerTop",
            value: function centerTop(_nbr) {
                var val = 0;
                if (this.isNumeric(_nbr)) {
                    var windowH = window.innerHeight;
                    val = (windowH - _nbr) / 2;
                }
                return val;
            }
        },
        {
            /**
     * @param {Number} _nbr
     * Calculates the abscissa corresponding to an element having param for width so that it is centered on the screen.
     * @returns {Number}
     */ key: "centerLeft",
            value: function centerLeft(_nbr) {
                var val = 0;
                if (this.isNumeric(_nbr)) {
                    var windowW = window.innerWidth;
                    val = (windowW - _nbr) / 2;
                }
                return val;
            }
        },
        {
            /**
     * @param {string} _url
     * @returns {string}
     */ key: "getUrl",
            value: function getUrl(_url) {
                var url = _url;
                var off = url.indexOf(" ");
                if (off >= 0) {
                    var selector = url.slice(off, url.length);
                    url = url.slice(0, off);
                }
                return url;
            }
        },
        {
            /**
     * @param {HTMLElement} _obj
     * Calculates the number of lines of an html element.
     * @returns {Number}
     */ key: "getLines",
            value: function getLines(_obj) {
                var width = _obj.offsetWidth, line = width / this.__CHAR_WIDTH;
                var lines = _obj.innerHTML.length / line;
                if (lines < 1) lines = 1;
                return Math.ceil(lines);
            }
        },
        {
            /**
     * Determines whether the device is mobile or desktop.
     */ key: "isTouchScreen",
            value: function isTouchScreen() {
                var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');
                var mq = function mq(query) {
                    return window.matchMedia(query).matches;
                };
                if ('ontouchstart' in window) {
                    return true;
                }
                // include the 'heartz' as a way to have a non matching MQ to help terminate the join
                // https://git.io/vznFH
                var query1 = [
                    '(',
                    prefixes.join('touch-enabled),('),
                    'heartz',
                    ')'
                ].join('');
                return mq(query1);
            }
        },
        {
            /**
     * @returns {object}
     */ key: "userAgent",
            value: function userAgent() {
                return navigator.userAgent;
            }
        },
        {
            /**
     * @param {Function} _callback
     * Checks whether the document is ready.
     * @returns {Promise}
     */ key: "ready",
            value: function ready(_callback) {
                return new Promise(function(resolve, reject) {
                    window.addEventListener('DOMContentLoaded', function(e) {
                        try {
                            _callback(e);
                            resolve(e);
                        } catch (error) {
                            reject(error);
                        }
                    }, false);
                });
            }
        },
        {
            /**
     * @param _text {String}
     * Modifies _text to construct a valid css selector
     * @return {*|string}
     */ key: "toSelector",
            value: function toSelector(_text) {
                var ret = _text;
                try {
                    if (typeof _text === "string") {
                        while(ret.indexOf("/") !== -1)ret = ret.replace("/", "_");
                        ret = ret.replace(/#/g, "");
                    }
                } catch (e) {
                    console.log(e);
                }
                return ret;
            }
        },
        {
            /**
     * @param _seconds {Number}
     * @param _callback {Function}
     * @return {number}
     */ key: "delay",
            value: function delay(_seconds, _callback) {
                return setTimeout(_callback, _seconds * 1000);
            }
        },
        {
            /**
     * @param _id {String|HTMLElement}
     * Deactivates an html element
     */ key: "disable",
            value: function disable(_id) {
                try {
                    var obj = _coding.default.get(_id);
                    obj.setAttribute("tabindex", "-1");
                    obj.setAttribute("aria-disabled", "true");
                    if (obj.tagName === "BUTTON") obj.setAttribute('disabled', true);
                    else obj.onclick = function() {
                        return false;
                    };
                } catch (e) {
                    console.log(e);
                }
            }
        },
        {
            /**
     * @param _id {String|HTMLElement}
     * Activates an html element
     */ key: "active",
            value: function active(_id) {
                try {
                    var obj = _coding.default.get(_id);
                    if (obj.tagName === "BUTTON") obj.removeAttribute('disabled');
                    else obj.onclick = function() {
                        return true;
                    };
                } catch (e) {
                    console.log(e);
                }
            }
        },
        {
            /**
     * @param _nbr {Number|String}
     * Format number in decimal
     * @return {string}
     */ key: "numberForTime",
            value: function numberForTime(_nbr) {
                var ret = '';
                if (parseInt(_nbr) < 10) ret = '0' + _nbr;
                else ret = _nbr + '';
                return ret;
            }
        },
        {
            /**
     * @return {{timer: (function((string|Date), (string|HTMLElement)): string), stringify: (function((string|Date), (string|HTMLElement), {noToday: boolean, onlyDate: boolean}): string)}}
     * Fires on date.
     */ key: "date",
            value: function date1() {
                var _this = this;
                return {
                    /**
             *
             * @param _date {string|Date}
             * @param _elem {string|HTMLElement}
             * Format the date and set a timer to manage date changes.
             * @return {string}
             */ timer: function(_date, _elem) {
                        var ret = "";
                        try {
                            var isString = function() {
                                return typeof _date === "string";
                            };
                            var text = {};
                            text.tab = {
                                en: {
                                    now: "now",
                                    min: " minute",
                                    hour: ' hour',
                                    day: ' day',
                                    week: ' week',
                                    month: ' month',
                                    year: ' year'
                                },
                                fr: {
                                    now: "\xe0 l'instant",
                                    min: " minute",
                                    hour: ' heure',
                                    day: ' jour',
                                    week: ' semaine',
                                    month: ' mois',
                                    year: ' an'
                                }
                            };
                            text.value = function(_lang) {
                                return {
                                    now: text.tab[_lang].now,
                                    minute: function(_min) {
                                        var min = parseInt(_min) <= 1 ? text.tab[_lang].min : text.tab[_lang].min + "s";
                                        if (_lang.trim() === "en") _min = parseInt(_min) <= 1 ? "a" : _min;
                                        else _min = parseInt(_min) <= 1 ? "une" : _min;
                                        return _lang.trim() === "en" ? _min + min + " ago" : "il y'a " + _min + min;
                                    },
                                    hour: function(_hour) {
                                        var hour = parseInt(_hour) <= 1 ? text.tab[_lang].hour : text.tab[_lang].hour + "s";
                                        if (_lang.trim() === "en") _hour = parseInt(_hour) <= 1 ? "a" : _hour;
                                        else _hour = parseInt(_hour) <= 1 ? "une" : _hour;
                                        return _lang.trim() === "en" ? _hour + hour + " ago" : "il y'a " + _hour + hour;
                                    },
                                    day: function(_day) {
                                        var day = parseInt(_day) <= 1 ? text.tab[_lang].day : text.tab[_lang].day + "s";
                                        if (_lang.trim() === "en") _day = parseInt(_day) <= 1 ? "a" : _day;
                                        else _day = parseInt(_day) <= 1 ? "un" : _day;
                                        return _lang.trim() === "en" ? _day + day + " ago" : "il y'a " + _day + day;
                                    },
                                    week: function(_week) {
                                        var week = parseInt(_week) <= 1 ? text.tab[_lang].week : text.tab[_lang].week + "s";
                                        if (_lang.trim() === "en") _week = parseInt(_week) <= 1 ? "a" : _week;
                                        else _week = parseInt(_week) <= 1 ? "une" : _week;
                                        return _lang.trim() === "en" ? _week + week + " ago" : "il y'a " + _week + week;
                                    },
                                    month: function(_month) {
                                        var month = parseInt(_month) <= 1 ? text.tab[_lang].month : text.tab[_lang].month + "s";
                                        month = month.replace("ss", "s");
                                        if (_lang.trim() === "en") _month = parseInt(_month) <= 1 ? "a" : _month;
                                        else _month = parseInt(_month) <= 1 ? "un" : _month;
                                        return _lang.trim() === "en" ? _month + month + " ago" : "il y'a " + _month + month;
                                    },
                                    year: function(_year) {
                                        var year = parseInt(_year) <= 1 ? text.tab[_lang].year : text.tab[_lang].year + "s";
                                        if (_lang.trim() === "en") _year = parseInt(_year) <= 1 ? "a" : _year;
                                        else _year = parseInt(_year) <= 1 ? "un" : _year;
                                        return _lang.trim() === "en" ? _year + year + " ago" : "il y'a " + _year + year;
                                    }
                                };
                            };
                            // worker
                            var date = isString() ? new Date(_date) : _date, lang = _this.cookie.read('lang');
                            lang = lang == null ? "en" : lang;
                            if (date != null) {
                                var _this1 = _this;
                                var worker = function() {
                                    var __HOUR = 60, __DAY = 24 * __HOUR, __WEEK = 7 * __DAY, __MONTH = 30 * __DAY, __YEAR = 12 * __MONTH;
                                    var current_date = new Date().getTime(), diff = Math.floor((current_date - date.getTime()) / 60000);
                                    if (0 <= diff && diff < 1) {
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, text.value(lang).now);
                                            _this1.delay(5, worker);
                                        }
                                        ret = text.value(lang).now;
                                    } else if (1 <= diff && diff < __HOUR) {
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, text.value(lang).minute(diff));
                                            _this1.delay(__HOUR, worker);
                                        }
                                        ret = text.value(lang).minute(diff);
                                    } else if (__HOUR <= diff && diff < __DAY) {
                                        ret = text.value(lang).hour(Math.floor(diff / __HOUR));
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, ret);
                                            _this1.delay(__DAY, worker);
                                        }
                                    } else if (__DAY <= diff && diff < __WEEK) {
                                        ret = text.value(lang).day(Math.floor(diff / __DAY));
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, ret);
                                            _this1.delay(__WEEK, worker);
                                        }
                                    } else if (__WEEK <= diff && diff < __MONTH) {
                                        ret = text.value(lang).week(Math.floor(diff / __WEEK));
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, ret);
                                            _this1.delay(__MONTH, worker);
                                        }
                                    } else if (__MONTH <= diff && diff < __YEAR) {
                                        ret = text.value(lang).month(Math.floor(diff / __MONTH));
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, ret);
                                            _this1.delay(__YEAR, worker);
                                        }
                                    } else if (__YEAR <= diff) {
                                        ret = text.value(lang).year(Math.floor(diff / __YEAR));
                                        if (_elem !== undefined) {
                                            _this1.setContent(_elem, ret);
                                            _this1.delay(__YEAR * 60000, worker);
                                        }
                                    }
                                };
                                worker();
                            }
                        } catch (e) {
                            console.log(e);
                        }
                        return ret;
                    },
                    /**
             *
             * @param _date {string|Date}
             * @param _elem {string|HTMLElement}
             * @param _param {{noToday: boolean, onlyDate: boolean}}
             * @return string
             */ stringify: function(_date, _elem, _param) {
                        var ret = "";
                        try {
                            var isString = function() {
                                return typeof _date === "string";
                            };
                            var text = {};
                            text.tab = {
                                en: {
                                    now: "now",
                                    today: "Today",
                                    hier: "Yesterday"
                                },
                                fr: {
                                    now: "\xe0 l'instant",
                                    today: "Aujourd'hui",
                                    hier: "Hier"
                                }
                            };
                            text.value = function(_lang) {
                                return {
                                    now: text.tab[_lang].now,
                                    today: text.tab[_lang].today,
                                    hier: text.tab[_lang].hier
                                };
                            };
                            var date = isString() ? new Date(_date) : _date, lang = _this.cookie.read('lang');
                            lang = lang == null ? "en" : lang;
                            if (date != null) {
                                var _this3 = _this;
                                var worker = function() {
                                    var __HOUR = 60, __DAY = 24 * __HOUR, __WEEK = 7 * __DAY, __MONTH = 30 * __DAY, __YEAR = 12 * __MONTH;
                                    var current_date = new Date().getTime(), diff = Math.floor((current_date - date.getTime()) / 60000);
                                    if (0 <= diff && diff < 1) {
                                        if (_elem !== undefined) {
                                            _this3.setContent(_elem, text.value(lang).now);
                                            _this3.delay(5, worker);
                                        }
                                        ret = text.value(lang).now;
                                    } else if (1 <= diff && diff < __DAY) {
                                        var content = '';
                                        if (_param !== undefined) {
                                            if (_param.onlyDate !== undefined && _param.onlyDate) content = text.value(lang).today;
                                            else {
                                                if (_param.noToday !== undefined && _param.noToday) content = _this3.numberForTime(date.getHours()) + ':' + _this3.numberForTime(date.getMinutes());
                                                else content = text.value(lang).today + ', ' + _this3.numberForTime(date.getHours()) + ':' + _this3.numberForTime(date.getMinutes());
                                            }
                                        } else content = text.value(lang).today + ', ' + _this3.numberForTime(date.getHours()) + ':' + _this3.numberForTime(date.getMinutes());
                                        if (_elem !== undefined) {
                                            _this3.setContent(_elem, content);
                                            _this3.delay(__HOUR * 60, worker);
                                        }
                                        ret = content;
                                    } else if (__DAY <= diff && diff < 2 * __DAY) {
                                        var content1 = '';
                                        if (_param !== undefined) {
                                            if (_param.onlyDate !== undefined && _param.onlyDate) content1 = text.value(lang).hier;
                                            else content1 = text.value(lang).hier + ', ' + _this3.numberForTime(date.getHours()) + ':' + _this3.numberForTime(date.getMinutes());
                                        } else content1 = text.value(lang).hier + ', ' + _this3.numberForTime(date.getHours()) + ':' + _this3.numberForTime(date.getMinutes());
                                        if (_elem !== undefined) {
                                            _this3.setContent(_elem, content1);
                                            _this3.delay(60 * 60 * 24, worker);
                                        }
                                        ret = content1;
                                    } else if (2 * __DAY <= diff) {
                                        var content2 = '', year = date.getFullYear() > 2000 ? ('' + date.getFullYear()).substr(2, 2) : date.getFullYear();
                                        if (lang === 'fr') content2 = _this3.numberForTime(date.getDate()) + '/' + _this3.numberForTime(date.getMonth() + 1) + '/' + year;
                                        else content2 = _this3.numberForTime(date.getMonth() + 1) + '/' + _this3.numberForTime(date.getDate()) + '/' + year;
                                        if (_param === undefined || _param.onlyDate === undefined || !_param.onlyDate) content2 += ', ' + _this3.numberForTime(date.getHours()) + ':' + _this3.numberForTime(date.getMinutes());
                                        if (_elem !== undefined) {
                                            _this3.setContent(_elem, content2);
                                            _this3.delay(60 * 60 * 24, worker);
                                        }
                                        ret = content2;
                                    }
                                };
                                worker();
                            }
                        } catch (e) {
                            console.log(e);
                        }
                        return ret;
                    }
                };
            }
        },
        {
            /**
     * @param _name {string}
     * Returns file extension.
     * @return {string}
     */ key: "getFileExtension",
            value: function getFileExtension(_name) {
                var ret = "";
                if (typeof _name === "string") {
                    var tab = _name.split('.');
                    ret = tab[tab.length - 1];
                }
                return ret;
            }
        },
        {
            /**
     * @param _name {string}
     * Returns file type
     * @return {string}
     */ key: "getFileType",
            value: function getFileType(_name) {
                var str = "";
                var ext = this.getFileExtension(_name);
                switch(ext){
                    case 'png':
                    case 'jpg':
                    case 'jpeg':
                    case 'bmp':
                    case 'ico':
                    case 'image':
                    case 'img':
                        str = "img";
                        break;
                    case 'mp4':
                    case 'mpeg':
                    case 'avi':
                    case 'mkv':
                    case 'flv':
                    case 'video':
                        str = "video";
                        break;
                    case 'mp3':
                    case 'ogg':
                    case 'wav':
                    case 'm4a':
                    case 'audio':
                        str = "audio";
                        break;
                    case 'doc':
                    case 'docx':
                    case 'xls':
                    case 'xlsx':
                    case 'ppt':
                    case 'pptx':
                    case 'pdf':
                    case 'document':
                        str = "document";
                        break;
                    default:
                        str = "document";
                        break;
                }
                return str;
            }
        },
        {
            /**
     * return a random number
     * @param max {number}
     * @return {number}
     */ key: "getRandomInt",
            value: function getRandomInt(max) {
                return Math.floor(Math.random() * Math.floor(max));
            }
        }
    ]);
    return DcUtilitaire;
}();
var _default = new DcUtilitaire();
exports.default = _default;
